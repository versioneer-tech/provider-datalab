# Copyright 2025, EOX (https://eox.at) and Versioneer (https://versioneer.at)
# SPDX-License-Identifier: Apache-2.0

apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: datalab-educates
  labels:
    provider: educates
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Datalab
  mode: Pipeline
  pipeline:
    - step: prepare-environment
      functionRef:
        name: crossplane-contrib-function-environment-configs
      input:
        apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          environmentConfigs:
            - type: Reference
              ref:
                name: datalab

    - step: observe-storage-secret
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              return {} if s is None else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}

              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}

              secret_name = spec.get("secretName") or meta.get("name")
              secret_namespace = storage_env.get("secretNamespace") or meta.get("namespace") or "default"

              key = f"observe-storage-secret-{xr_name}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": xr_namespace,
                      "annotations": {"crossplane.io/composition-resource-name": key},
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {"name": secret_name, "namespace": secret_namespace},
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                      "watch": False,
                  },
              })

    - step: observe-database-secret
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              return {} if s is None else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}

              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              secret_name = "pg0-pguser-postgres"
              secret_namespace = meta.get("name")

              key = f"observe-database-secret-{xr_name}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": xr_namespace,
                      "annotations": {"crossplane.io/composition-resource-name": key},
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {"name": secret_name, "namespace": secret_namespace},
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                      "watch": False,
                  },
              })

    - step: update-secret-datalab
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import base64 as _base64
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              if s is None:
                  return {}
              return s if isinstance(s, dict) else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def _safe_str(v):
              return str(v).strip()

          def _b64get_any(d, keys):
              if not d:
                  return None
              for k in keys:
                  v = d.get(k)
                  if v is None:
                      continue
                  try:
                      return _base64.b64decode(v).decode("utf-8")
                  except Exception:
                      continue
              return None

          def _extract_data(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              st = (od.get("status") or {}).get("atProvider") or {}
              m1 = st.get("manifest") or {}
              m2 = (st.get("raw") or {}).get("manifest") or {}
              return (m1.get("data") or m1.get("stringData") or m2.get("data") or m2.get("stringData") or {}) or {}

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}

              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}

              obs = (getattr(req.observed, "resources", {}) or {}).get(f"observe-storage-secret-{xr_name}")
              data_b64 = _extract_data(obs)

              access_key = _b64get_any(data_b64, ["AWS_ACCESS_KEY_ID","accessKey","username","CONSOLE_ACCESS_KEY","attribute.access"])
              secret_key = _b64get_any(data_b64, ["AWS_SECRET_ACCESS_KEY","secretKey","password","CONSOLE_SECRET_KEY","attribute.secret"])
              endpoint = _b64get_any(data_b64, ["AWS_ENDPOINT_URL"]) or storage_env.get("endpoint", "")
              region = _b64get_any(data_b64, ["AWS_REGION"]) or storage_env.get("region", "")
              rtype = storage_env.get("type", "")
              provider = storage_env.get("provider", "")
              force_path_style = str(storage_env.get("force_path_style", "true")).lower()

              if not access_key or not secret_key:
                  return

              config_data = (
                  f"[{access_key}]\n"
                  f"type = {rtype}\n"
                  f"provider = {provider}\n"
                  f"endpoint = {endpoint}\n"
                  f"region = {region}\n"
                  f"access_key_id = {access_key}\n"
                  f"secret_access_key = {secret_key}\n"
                  f"force_path_style = {force_path_style}\n"
              )

              manifest = {
                  "apiVersion": "v1",
                  "kind": "Secret",
                  "metadata": {"name": f"{xr_name}-datalab", "namespace": xr_namespace},
                  "type": "Opaque",
                  "stringData": {
                      "remote": access_key,
                      "remotePath": "/",
                      "configData": config_data,
                      "AWS_ACCESS_KEY_ID": access_key,
                      "AWS_SECRET_ACCESS_KEY": secret_key,
                      "AWS_REGION": region,
                      "AWS_ENDPOINT_URL": endpoint,
                      "AWS_S3_FORCE_PATH_STYLE": force_path_style,
                  },
              }

              db_obs = (getattr(req.observed, "resources", {}) or {}).get(f"observe-database-secret-{xr_name}")
              db_data_b64 = _extract_data(db_obs)
              if db_data_b64:
                  manifest["stringData"]["DATABASE_URL"] = _b64get_any(db_data_b64, ["uri"])
                  manifest["stringData"]["DATABASE_NAME"] = _b64get_any(db_data_b64, ["dbname"])
                  manifest["stringData"]["DATABASE_HOST"] = _b64get_any(db_data_b64, ["host"])
                  manifest["stringData"]["DATABASE_PORT"] = _b64get_any(db_data_b64, ["port"])
                  manifest["stringData"]["DATABASE_USER"] = _b64get_any(db_data_b64, ["user"])
                  manifest["stringData"]["DATABASE_PASSWORD"] = _b64get_any(db_data_b64, ["password"])

                  db_env = env.get("database") or {}
                  gateway_env = db_env.get("gateway") or {}

                  gateway_parent_name = _safe_str(gateway_env.get("parentName") or "")
                  gateway_parent_ns = _safe_str(gateway_env.get("parentNamespace") or "")
                  gateway_section = _safe_str(gateway_env.get("sectionName") or "")
                  has_gateway_parent = bool(gateway_parent_name and gateway_parent_ns and gateway_section)

                  ingress_env = env.get("ingress") or {}

                  ingress_domain = ingress_env.get("domain", "default")

                  if has_gateway_parent:
                      manifest["stringData"]["DATABASE_HOST_EXTERNAL"] = f"pgo-{xr_name}.{ingress_domain}"

              key = f"secret-{xr_name}-datalab"
              rsp.desired.resources[key].resource.update(manifest)
              rsp.desired.resources[key].ready = True

    - step: update-keycloak-objects
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def _distinct(seq):
              return list(dict.fromkeys(seq))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}

              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              iam_env = env.get("iam") or {}
              ingress_env = env.get("ingress") or {}
              realm = iam_env.get("realm", "default")
              domain = ingress_env.get("domain", "default")
              url = f"https://{xr_name}.{domain}"

              def put(key_base, body_base, name_override=xr_name):
                  key = f"{key_base}-{name_override}"
                  body = body_base.copy()
                  md = body.setdefault("metadata", {})
                  md.setdefault("name", name_override)
                  md.setdefault("namespace", xr_namespace)
                  ann = md.setdefault("annotations", {})
                  ann["crossplane.io/composition-resource-name"] = key
                  rsp.desired.resources[key].resource.update(body)

              put("keycloak-group", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Group",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {"name": xr_name, "realmId": realm},
                  },
              })

              put("keycloak-group-admin", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Group",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {"name": f"{xr_name}-admin", "realmId": realm},
                  },
              }, f"{xr_name}-admin")

              put("keycloak-mapper", {
                  "apiVersion": "openidgroup.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "GroupMembershipProtocolMapper",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "claimName": "groups",
                          "clientIdSelector": {"matchLabels": {"crossplane.io/claim-name": xr_name}},
                          "addToAccessToken": False,
                          "addToIdToken": True,
                          "addToUserinfo": False,
                          "fullPath": False,
                          "name": xr_name,
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-client", {
                  "apiVersion": "openidclient.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Client",
                  "metadata": {"labels": {"crossplane.io/claim-name": xr_name}},
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": xr_name,
                          "clientId": xr_name,
                          "rootUrl": url,
                          "adminUrl": url,
                          "accessType": "PUBLIC",
                          "standardFlowEnabled": True,
                          "implicitFlowEnabled": True,
                          "directAccessGrantsEnabled": False,
                          "serviceAccountsEnabled": False,
                          "oauth2DeviceAuthorizationGrantEnabled": True,
                          "webOrigins": [f"{url}/*", "http://localhost:*"],
                          "validRedirectUris": [f"{url}/*", "http://localhost:*"],
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-role-user", {
                  "apiVersion": "role.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Role",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": "ws_access",
                          "clientIdRef": {"name": xr_name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                      },
                  },
              }, f"{xr_name}-ws-access")

              put("keycloak-role-admin", {
                  "apiVersion": "role.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Role",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": "ws_admin",
                          "clientIdRef": {"name": xr_name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                      },
                  },
              }, f"{xr_name}-ws-admin")

              put("keycloak-roles-user", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Roles",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "realmId": realm,
                          "groupIdRef": {"name": xr_name, "policy": {"resolution": "Required"}},
                          "roleIdsRefs": [{"name": f"{xr_name}-ws-access", "policy": {"resolution": "Required"}}],
                      },
                  },
              })

              put("keycloak-roles-admin", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Roles",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "realmId": realm,
                          "groupIdRef": {"name": f"{xr_name}-admin", "policy": {"resolution": "Required"}},
                          "roleIdsRefs": [{"name": f"{xr_name}-ws-admin", "policy": {"resolution": "Required"}}],
                      },
                  },
              }, f"{xr_name}-admin")

              users = list(spec.get("users", []) or [])
              userOverrides = spec.get("userOverrides", {}) or {}

              role_admins = [
                  u for u in users
                  if str(((userOverrides.get(u) or {}).get("role") or "")).strip() == "admin"
              ]

              admins = _distinct((users[0:1] or []) + role_admins)

              put("keycloak-memberships-users", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Memberships",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "groupIdRef": {"name": xr_name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                          "members": users,
                      },
                  },
              })

              put("keycloak-memberships-admins", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Memberships",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "groupIdRef": {"name": f"{xr_name}-admin", "policy": {"resolution": "Required"}},
                          "realmId": realm,
                          "members": admins,
                      },
                  },
              }, f"{xr_name}-admin")

    - step: update-educates-objects
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import base64 as _base64
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def _boolish(v):
              if isinstance(v, bool):
                  return v
              return str(v).lower() in ("true", "1", "yes", "on")

          def _b64get_any(d, keys):
              if not d:
                  return None
              for k in keys:
                  v = d.get(k)
                  if v is None:
                      continue
                  try:
                      return _base64.b64decode(v).decode("utf-8")
                  except Exception:
                      try:
                          return str(v)
                      except Exception:
                          pass
              return None

          def _extract_data(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              st = (od.get("status") or {}).get("atProvider") or {}
              m1 = st.get("manifest") or {}
              m2 = (st.get("raw") or {}).get("manifest") or {}
              return (m1.get("data") or m1.get("stringData") or m2.get("data") or m2.get("stringData") or {}) or {}

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              
              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              files = spec.get("files") or []
              sessions = list(spec.get("sessions") or [])
              vcluster = _boolish(spec.get("vcluster", False))

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              defaults = (env.get("defaults") or {})
              env_quota = (defaults.get("quota") or {})
              quota = (spec.get("quota") or {})

              memory = quota.get("memory") or env_quota.get("memory") or "2Gi"
              storage = quota.get("storage") or env_quota.get("storage") or "1Gi"
              budget = quota.get("budget") or env_quota.get("budget") or "medium"

              env_security = (defaults.get("security") or {})
              security = (spec.get("security") or {})

              policy = (security.get("policy") or env_security.get("policy") or "baseline")

              ka = security.get("kubernetesAccess")
              if ka is None:
                  ka = env_security.get("kubernetesAccess")
              if ka is None:
                  ka = True
              kubernetes_access = _boolish(ka)

              role = (security.get("kubernetesRole") or env_security.get("kubernetesRole") or "edit")

              ingress_env = env.get("ingress") or {}
              storage_env = env.get("storage") or {}
              packages = env.get("packages") or []
              auth_env = env.get("auth") or {}

              ingress_class = ingress_env.get("class", "")
              ingress_domain = ingress_env.get("domain", "default")
              ingress_secret = ingress_env.get("secret", "wildcard-tls")

              auth_type = (auth_env.get("type") or "credentials").strip().lower()

              storage_secret_name = f"{xr_name}-datalab"

              obs = (getattr(req.observed, "resources", {}) or {}).get(f"observe-storage-secret-{xr_name}")
              data_b64 = _extract_data(obs)

              access_key = _b64get_any(data_b64, ["AWS_ACCESS_KEY_ID","accessKey","username","CONSOLE_ACCESS_KEY","attribute.access"])
              secret_key = _b64get_any(data_b64, ["AWS_SECRET_ACCESS_KEY","secretKey","password","CONSOLE_SECRET_KEY","attribute.secret"])

              session_username = "*"
              session_password = ""

              if auth_type == "credentials" and access_key:
                  session_username = access_key
                  session_password = secret_key

              allow_web_egress = {
                  "apiVersion": "networking.k8s.io/v1",
                  "kind": "NetworkPolicy",
                  "metadata": {"name": "allow-web-egress"},
                  "spec": {
                      "podSelector": {},
                      "policyTypes": ["Egress"],
                      "egress": [
                          {
                              "to": [
                                  {"namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": "kube-system"}}}
                              ],
                              "ports": [
                                  {"protocol": "UDP", "port": 53},
                                  {"protocol": "TCP", "port": 53}
                              ]
                          },
                          {
                              "to": [
                                  {"ipBlock": {"cidr": "10.0.0.0/8"}},
                                  {"ipBlock": {"cidr": "172.16.0.0/12"}},
                                  {"ipBlock": {"cidr": "192.168.0.0/16"}},
                                  {"ipBlock": {"cidr": "100.64.0.0/10"}}
                              ]
                          },
                          {"to": [{"ipBlock": {"cidr": "fc00::/7"}}]},
                          {"to": [{"namespaceSelector": {}}]},
                          {"to": [{"ipBlock": {"cidr": "0.0.0.0/0", "except": ["169.254.42.42/32"]}}]},
                          {"to": [{"ipBlock": {"cidr": "::/0", "except": ["fd00:42::42/128"]}}]}
                      ]
                  }
              }

              workshop = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "Workshop",
                  "metadata": {"name": xr_name},
                  "spec": {
                      "title": "Default DataLab",
                      "description": "A default DataLab environment.",
                      "version": "1.0",
                      "session": {
                          "applications": {
                              "console": {"enabled": False},
                              "editor": {"enabled": True},
                              "slides": {"enabled": False},
                              "terminal": {"enabled": True},
                              "vcluster": {"enabled": vcluster, "version": "1.30"},
                              "workshop": {"enabled": bool(files)}
                          },
                          "dashboards": [
                              {"name": "Data", "url": "$(ingress_protocol)://data-$(session_name).$(ingress_domain)/"}
                          ],
                          "ingresses": [
                              {
                                  "name": "data",
                                  "protocol": "http",
                                  "host": "data.$(workshop_namespace).svc.$(cluster_domain)",
                                  "port": 8080
                              }
                          ],
                          "resources": {"memory": memory, "storage": storage},
                          "namespaces": {
                              "budget": budget,
                              "role": role,
                              "security": {
                                  "policy": policy,
                                  "token": {"enabled": kubernetes_access}
                              }
                          },
                          "envFrom": [{"secretRef": {"name": storage_secret_name}}],
                          "objects": []
                      },
                      "workshop": {
                          "files": files,
                          "packages": packages
                      },
                      "environment": {
                          "secrets": [{"name": storage_secret_name, "namespace": xr_namespace}],
                          "objects": [
                              allow_web_egress,
                              {
                                  "apiVersion": "v1",
                                  "kind": "PersistentVolumeClaim",
                                  "metadata": {"name": storage_secret_name},
                                  "spec": {
                                      "accessModes": ["ReadOnlyMany"],
                                      "resources": {"requests": {"storage": "1Mi"}},
                                      "storageClassName": "csi-rclone"
                                  }
                              },
                              {
                                  "apiVersion": "apps/v1",
                                  "kind": "Deployment",
                                  "metadata": {
                                      "name": "data",
                                      "labels": {
                                          "app.kubernetes.io/instance": "data",
                                          "app.kubernetes.io/name": "data"
                                      }
                                  },
                                  "spec": {
                                      "replicas": 1,
                                      "selector": {
                                          "matchLabels": {
                                              "app.kubernetes.io/instance": "data",
                                              "app.kubernetes.io/name": "data"
                                          }
                                      },
                                      "template": {
                                          "metadata": {
                                              "labels": {
                                                  "app.kubernetes.io/instance": "data",
                                                  "app.kubernetes.io/name": "data"
                                              }
                                          },
                                          "spec": {
                                              "serviceAccountName": "$(service_account)",
                                              "containers": [{
                                                  "name": "data",
                                                  "image": "ghcr.io/versioneer-tech/package-r:v2025.7.1",
                                                  "imagePullPolicy": "Always",
                                                  "ports": [{"name": "http", "containerPort": 8080}],
                                                  "env": [
                                                      {"name": "FB_AUTH_MAPPER", "value": "writer-noshare"},
                                                      {"name": "WORKSPACE", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_ROOT", "value": "/data"},
                                                      {"name": "FB_BRANDING_NAME", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_AUTH_HEADER", "value": "Accept"},
                                                      {"name": "AWS_ACCESS_KEY_ID", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ACCESS_KEY_ID"}}},
                                                      {"name": "AWS_SECRET_ACCESS_KEY", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_SECRET_ACCESS_KEY"}}},
                                                      {"name": "AWS_REGION", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_REGION"}}},
                                                      {"name": "AWS_ENDPOINT_URL", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ENDPOINT_URL"}}},
                                                      {"name": "AWS_S3_FORCE_PATH_STYLE", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_S3_FORCE_PATH_STYLE"}}}
                                                  ],
                                                  "resources": {
                                                      "requests": {"cpu": "100m", "memory": "128Mi"},
                                                      "limits": {"cpu": "1", "memory": "512Mi"}
                                                  },
                                                  "volumeMounts": [{"name": "data", "mountPath": "/data"}]
                                              }],
                                              "volumes": [{"name": "data", "persistentVolumeClaim": {"claimName": storage_secret_name}}]
                                          }
                                      }
                                  }
                              },
                              {
                                  "apiVersion": "v1",
                                  "kind": "Service",
                                  "metadata": {"name": "data"},
                                  "spec": {
                                      "type": "ClusterIP",
                                      "selector": {
                                          "app.kubernetes.io/instance": "data",
                                          "app.kubernetes.io/name": "data"
                                      },
                                      "ports": [
                                          {"name": "http", "port": 8080, "targetPort": "http", "protocol": "TCP"}
                                      ]
                                  }
                              }
                          ]
                      }
                  }
              }

              if policy == "privileged":
                  workshop["spec"]["session"]["applications"]["docker"] = {
                      "enabled": True,
                      "storage": "20Gi"
                  }

              if vcluster:
                  service_cidr = (
                      str((env.get("network") or {}).get("serviceCIDR") or "") or
                      "10.43.0.0/16"
                  )
                  workshop["spec"]["session"]["objects"].append({
                      "apiVersion": "v1",
                      "kind": "ConfigMap",
                      "metadata": {
                          "name": "vc-cidr-my-vcluster",
                          "namespace": "$(session_namespace)-vc"
                      },
                      "data": {"cidr": service_cidr}
                  })

              environment = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "WorkshopEnvironment",
                  "metadata": {"name": xr_name},
                  "spec": {
                      "analytics": {"amplitude": {"trackingId": ""}},
                      "cookies": {},
                      "environment": {"objects": [], "secrets": []},
                      "request": {"enabled": False},
                      "session": {"ingress": {"class": ingress_class, "domain": ingress_domain, "secret": ingress_secret}},
                      "theme": {"name": "default-website-theme"},
                      "workshop": {"name": xr_name}
                  }
              }

              def emit(kind, manifest, key_suffix=""):
                  suffix = f"-{xr_name}{('-' + key_suffix) if key_suffix else ''}"
                  key = f"{kind.lower()}{suffix}"
                  body = {
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": xr_namespace,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                          "forProvider": {"manifest": manifest},
                          "readiness": {"policy": "SuccessfulCreate"},
                          "watch": True
                      }
                  }
                  rsp.desired.resources[key].resource.update(body)

              emit("Workshop", workshop)
              emit("WorkshopEnvironment", environment)

              for sid in sessions:
                  session_manifest = {
                      "apiVersion": "training.educates.dev/v1beta1",
                      "kind": "WorkshopSession",
                      "metadata": {"name": f"{xr_name}-{sid}"},
                      "spec": {
                          "environment": {"name": xr_name},
                          "session": {
                              "id": str(sid),
                              "ingress": {"domain": ingress_domain, "secret": ingress_secret},
                              "env": [
                                  {"name": "SESSION_NAME", "value": f"{xr_name}-{sid}"},
                                  {"name": "FRAME_ANCESTORS", "value": ""}
                              ],
                              "username": session_username,
                              "password": session_password
                          }
                      }
                  }
                  emit("WorkshopSession", session_manifest, key_suffix=str(sid))

    - step: update-database-objects
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def _extract_manifest(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              atp = (od.get("status") or {}).get("atProvider") or {}
              m1 = atp.get("manifest") or {}
              m2 = (atp.get("raw") or {}).get("manifest") or {}
              return (m1 or m2) or {}

          def _safe_str(v):
              return str(v).strip()

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}

              xr_name = meta.get("name")
              xr_namespace = meta.get("namespace") or "default"

              db_hosts = spec.get("databases") or {}
              if not isinstance(db_hosts, dict) or not db_hosts:
                  return

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}

              ingress_env = env.get("ingress") or {}
              ingress_domain = ingress_env.get("domain", "default")

              db_env = env.get("database") or {}
              gateway_env = db_env.get("gateway") or {}

              gateway_parent_name = _safe_str(gateway_env.get("parentName") or "")
              gateway_parent_ns = _safe_str(gateway_env.get("parentNamespace") or "")
              gateway_section = _safe_str(gateway_env.get("sectionName") or "")
              has_gateway_parent = bool(gateway_parent_name and gateway_parent_ns and gateway_section)

              data_sc_default = _safe_str(db_env.get("storageClassName") or "")
              backup_sc_default = _safe_str(db_env.get("backupStorageClassName") or "")

              users = list(spec.get("users", []) or [])
              admin_user = "postgres"
              other_users = [u for u in users if _safe_str(u) and _safe_str(u) != admin_user]
              users_all = [admin_user] + other_users

              observed = getattr(req.observed, "resources", None) or {}
              env_key = f"workshopenvironment-{xr_name}"
              env_manifest = _extract_manifest(observed.get(env_key))

              educates_status = (env_manifest.get("status") or {}).get("educates") or {}
              workshop_ns = _safe_str(educates_status.get("namespace") or "")
              phase = _safe_str(educates_status.get("phase") or "")

              if not workshop_ns or phase.lower() not in ("running", "ready"):
                  return

              def emit_obj(key, manifest, readiness_policy="SuccessfulCreate", watch=True):
                  body = {
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": xr_namespace,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                          "forProvider": {"manifest": manifest},
                          "readiness": {"policy": readiness_policy},
                          "watch": watch
                      }
                  }
                  rsp.desired.resources[key].resource.update(body)

              for host_key in sorted(list(db_hosts.keys())):
                  if not isinstance(host_key, str) or not host_key.strip():
                      continue

                  host_cfg = db_hosts.get(host_key) or {}
                  if not isinstance(host_cfg, dict):
                      continue

                  dbnames = list(host_cfg.get("names") or [])
                  dbnames = [_safe_str(x) for x in dbnames if _safe_str(x)]
                  if not dbnames:
                      continue

                  db_storage = _safe_str(host_cfg.get("storage") or "")
                  backup_storage = _safe_str(host_cfg.get("backupStorage") or "")
                  if not db_storage or not backup_storage:
                      continue

                  db_storage_class = _safe_str(host_cfg.get("storageClassName") or data_sc_default)
                  backup_storage_class = _safe_str(host_cfg.get("backupStorageClassName") or backup_sc_default)

                  cluster_name = f"{host_key.strip()}"
                  cm_name = f"{cluster_name}-init-sql"
                  init_sql = "\\set ON_ERROR_STOP on\n\\connect postgres\n"

                  cm = {
                      "apiVersion": "v1",
                      "kind": "ConfigMap",
                      "metadata": {"name": cm_name, "namespace": workshop_ns},
                      "data": {"init.sql": init_sql},
                  }

                  data_vcs = {
                      "accessModes": ["ReadWriteOnce"],
                      "resources": {"requests": {"storage": db_storage}},
                  }
                  if db_storage_class:
                      data_vcs["storageClassName"] = db_storage_class

                  repo_vcs = {
                      "accessModes": ["ReadWriteOnce"],
                      "resources": {"requests": {"storage": backup_storage}},
                  }
                  if backup_storage_class:
                      repo_vcs["storageClassName"] = backup_storage_class

                  pg_cluster = {
                      "apiVersion": "postgres-operator.crunchydata.com/v1beta1",
                      "kind": "PostgresCluster",
                      "metadata": {"name": cluster_name, "namespace": workshop_ns},
                      "spec": {
                          "postgresVersion": 17,
                          "databaseInitSQL": {"name": cm_name, "key": "init.sql"},
                          "instances": [{
                              "name": "primary",
                              "replicas": 1,
                              "dataVolumeClaimSpec": data_vcs,
                          }],
                          "backups": {
                              "pgbackrest": {
                                "global": {
                                    "repo1-retention-full-type": "count",
                                    "repo1-retention-full": "4",
                                    "repo1-retention-archive-type": "days",
                                    "repo1-retention-archive": "14",
                                    "repo1-path": f"/pgbackrest/databases/{cluster_name}/repo1",
                                },
                                "repos": [{
                                    "name": "repo1",
                                    "schedules": {
                                        "full": "0 1 * * 0",
                                        "differential": "0 1 * * 1-6",
                                    },
                                    "volume": {
                                        "volumeClaimSpec": repo_vcs,
                                    },
                                }],
                              }
                          },
                      },
                  }

                  if users_all:
                      pg_cluster["spec"]["users"] = (
                          [{"name": admin_user, "databases": dbnames}] +
                          [{"name": u} for u in other_users]
                      )

                  emit_obj(f"db-configmap-{xr_name}-{cluster_name}", cm, readiness_policy="SuccessfulCreate", watch=True)
                  emit_obj(f"db-postgrescluster-{xr_name}-{cluster_name}", pg_cluster, readiness_policy="DeriveFromObject", watch=True)

                  if not has_gateway_parent:
                      continue

                  hostname = f"{cluster_name}-{workshop_ns}.{ingress_domain}"
                  route = {
                      "apiVersion": "gateway.networking.k8s.io/v1alpha2",
                      "kind": "TLSRoute",
                      "metadata": {"name": cluster_name, "namespace": workshop_ns},
                      "spec": {
                          "parentRefs": [{
                              "name": gateway_parent_name,
                              "namespace": gateway_parent_ns,
                              "sectionName": gateway_section
                          }],
                          "hostnames": [hostname],
                          "rules": [{
                              "backendRefs": [{
                                "name": f"{cluster_name}-primary",
                                "port": 5432
                              }]
                          }]
                      }
                  }

                  emit_obj(f"db-tlsroute-{xr_name}-{cluster_name}", route, readiness_policy="DeriveFromObject", watch=True)

    - step: detect-educates-status
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as jf
          from google.protobuf import struct_pb2 as st

          def _to_dict(s):
              return {} if s is None else jf.MessageToDict(s, preserving_proto_field_name=True)

          def _extract_manifest(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              atp = (od.get("status") or {}).get("atProvider") or {}
              return (atp.get("manifest") or (atp.get("raw") or {}).get("manifest") or {}) or {}

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              observed = getattr(req.observed, "resources", None) or {}
              xr_obs = _to_dict(req.observed.composite.resource)
              meta = xr_obs.get("metadata", {}) or {}
              spec = xr_obs.get("spec", {}) or {}
              
              xr_name = meta.get("name")

              sessions_map = {}

              for sid in spec.get("sessions") or []:
                  key = f"workshopsession-{xr_name}-{sid}"
                  manifest = _extract_manifest(observed.get(key))
                  if not manifest:
                      continue

                  ws_spec = (manifest.get("spec") or {}).get("session") or {}
                  ws_id = str(ws_spec.get("id") or sid)

                  educates = (manifest.get("status") or {}).get("educates") or {}
                  phase = educates.get("phase")
                  url = educates.get("url")

                  if phase == "Running" and url:
                      sessions_map[ws_id] = {"url": url}

              cur_status = (xr_obs.get("status") or {}).copy()
              cur_sessions = (cur_status.get("sessions") or {}).copy()
              cur_sessions.update(sessions_map)
              cur_status["sessions"] = cur_sessions

              v = st.Value()
              jf.ParseDict(cur_status, v)
              rsp.desired.composite.resource.fields["status"].CopyFrom(v)

    - step: detect-datalab-status
      functionRef:
        name: crossplane-contrib-function-auto-ready
