# Copyright 2025, EOX (https://eox.at) and Versioneer (https://versioneer.at)
# SPDX-License-Identifier: Apache-2.0

apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: datalab-educates
  labels:
    provider: educates
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Datalab
  mode: Pipeline
  pipeline:
    - step: prepare-environment
      functionRef:
        name: crossplane-contrib-function-environment-configs
      input:
        apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          environmentConfigs:
            - type: Reference
              ref:
                name: datalab

    - step: observe-storage-secret
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              return {} if s is None else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              secret_name = spec.get("secretName") or meta.get("name")

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}

              ns = storage_env.get("secretNamespace") or meta.get("namespace") or "default"

              key = f"observe-secret-{secret_name}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": key},
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {"name": secret_name, "namespace": ns},
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                      "watch": False,
                  },
              })

    - step: update-secret-datalab
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import base64 as _base64
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              if s is None:
                  return {}
              return s if isinstance(s, dict) else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def _b64get_any(d, keys):
              if not d:
                  return None
              for k in keys:
                  v = d.get(k)
                  if v is None:
                      continue
                  try:
                      return _base64.b64decode(v).decode("utf-8")
                  except Exception:
                      continue
              return None

          def _extract_data(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              st = (od.get("status") or {}).get("atProvider") or {}
              m1 = st.get("manifest") or {}
              m2 = (st.get("raw") or {}).get("manifest") or {}
              return (m1.get("data") or m1.get("stringData") or m2.get("data") or m2.get("stringData") or {})

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              secret_name = spec.get("secretName") or meta.get("name")

              ctx = _to_dict(req.context)
              ns_from_xr = meta.get("namespace") or "default"
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}
              ns = storage_env.get("secretNamespace") or ns_from_xr

              obs = (getattr(req.observed, "resources", {}) or {}).get(f"observe-secret-{secret_name}")
              data_b64 = _extract_data(obs)

              access_key = _b64get_any(data_b64, ["AWS_ACCESS_KEY_ID","accessKey","username","CONSOLE_ACCESS_KEY","attribute.access"])
              secret_key = _b64get_any(data_b64, ["AWS_SECRET_ACCESS_KEY","secretKey","password","CONSOLE_SECRET_KEY","attribute.secret"])
              endpoint   = _b64get_any(data_b64, ["AWS_ENDPOINT_URL"]) or storage_env.get("endpoint", "")
              region     = _b64get_any(data_b64, ["AWS_REGION"]) or storage_env.get("region", "")
              rtype      = storage_env.get("type", "")
              provider   = storage_env.get("provider", "")
              force_path_style = str(storage_env.get("force_path_style", "true")).lower()

              if not access_key or not secret_key:
                  return

              config_data = (
                  f"[{access_key}]\n"
                  f"type = {rtype}\n"
                  f"provider = {provider}\n"
                  f"endpoint = {endpoint}\n"
                  f"region = {region}\n"
                  f"access_key_id = {access_key}\n"
                  f"secret_access_key = {secret_key}\n"
                  f"force_path_style = {force_path_style}\n"
              )

              out_name = f"{secret_name}-datalab"
              manifest = {
                  "apiVersion": "v1",
                  "kind": "Secret",
                  "metadata": {"name": out_name, "namespace": ns},
                  "type": "Opaque",
                  "stringData": {
                      "remote": access_key,
                      "remotePath": "/",
                      "configData": config_data,
                      "AWS_ACCESS_KEY_ID": access_key,
                      "AWS_SECRET_ACCESS_KEY": secret_key,
                      "AWS_REGION": region,
                      "AWS_ENDPOINT_URL": endpoint,
                      "AWS_S3_FORCE_PATH_STYLE": force_path_style,
                  },
              }

              key = f"secret-{secret_name}-datalab"
              rsp.desired.resources[key].resource.update(manifest)
              rsp.desired.resources[key].ready = True

    - step: update-keycloak-objects
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name")
              ns = meta.get("namespace") or "default"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              iam_env = env.get("iam") or {}
              ingress_env = env.get("ingress") or {}
              realm = iam_env.get("realm", "default")
              domain = ingress_env.get("domain", "default")
              url = f"https://{name}.{domain}"

              def put(key_base, body_base):
                  key = f"{key_base}-{name}"
                  body = body_base.copy()
                  md = body.setdefault("metadata", {})
                  md.setdefault("name", name if key_base != "keycloak-role" else f"{name}-ws-access")
                  md.setdefault("namespace", ns)
                  ann = md.setdefault("annotations", {})
                  ann["crossplane.io/composition-resource-name"] = key
                  rsp.desired.resources[key].resource.update(body)

              put("keycloak-group", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Group",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {"name": name, "realmId": realm},
                  },
              })

              put("keycloak-mapper", {
                  "apiVersion": "openidgroup.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "GroupMembershipProtocolMapper",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "claimName": "groups",
                          "clientIdSelector": {"matchLabels": {"crossplane.io/claim-name": name}},
                          "addToAccessToken": False,
                          "addToIdToken": True,
                          "addToUserinfo": False,
                          "fullPath": False,
                          "name": "group-membership-mapper",
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-client", {
                  "apiVersion": "openidclient.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Client",
                  "metadata": {"labels": {"crossplane.io/claim-name": name}},
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": name,
                          "clientId": name,
                          "rootUrl": url,
                          "adminUrl": url,
                          "accessType": "PUBLIC",
                          "standardFlowEnabled": True,
                          "implicitFlowEnabled": True,
                          "directAccessGrantsEnabled": False,
                          "serviceAccountsEnabled": False,
                          "oauth2DeviceAuthorizationGrantEnabled": True,
                          "webOrigins": [f"{url}/*", "http://localhost:*"],
                          "validRedirectUris": [f"{url}/*", "http://localhost:*"],
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-role", {
                  "apiVersion": "role.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Role",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": "ws_access",
                          "clientIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-roles", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Roles",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "realmId": realm,
                          "groupIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "roleIdsRefs": [{"name": f"{name}-ws-access", "policy": {"resolution": "Required"}}],
                      },
                  },
              })

              users = list(spec.get("users", []) or [])

              put("keycloak-memberships", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Memberships",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "groupIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                          "members": users,
                      },
                  },
              })

    - step: update-educates-objects
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import base64 as _base64
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def _boolish(v):
              if isinstance(v, bool):
                  return v
              return str(v).lower() in ("true", "1", "yes", "on")

          def _b64get_any(d, keys):
              if not d:
                  return None
              for k in keys:
                  v = d.get(k)
                  if v is None:
                      continue
                  try:
                      return _base64.b64decode(v).decode("utf-8")
                  except Exception:
                      # also allow plain stringData path (not base64)
                      try:
                          return str(v)
                      except Exception:
                          pass
              return None

          def _extract_data(objres):
              """Extract Secret .data/.stringData from an observed kubernetes.m.crossplane.io/Object."""
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              st = (od.get("status") or {}).get("atProvider") or {}
              m1 = st.get("manifest") or {}
              m2 = (st.get("raw") or {}).get("manifest") or {}
              return (m1.get("data") or m1.get("stringData") or m2.get("data") or m2.get("stringData") or {}) or {}

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name")
              ns = meta.get("namespace") or "default"

              files = spec.get("files") or []
              sessions = list(spec.get("sessions") or [])
              vcluster = _boolish(spec.get("vcluster", False))

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              defaults = (env.get("defaults") or {})
              env_quota = (defaults.get("quota") or {})
              quota = (spec.get("quota") or {})

              memory = quota.get("memory") or env_quota.get("memory") or "2Gi"
              storage = quota.get("storage") or env_quota.get("storage") or "1Gi"
              budget  = quota.get("budget")  or env_quota.get("budget")  or "medium"

              env_security = (defaults.get("security") or {})
              security = (spec.get("security") or {})

              policy = (security.get("policy") or env_security.get("policy") or "baseline")

              ka = security.get("kubernetesAccess")
              if ka is None:
                  ka = env_security.get("kubernetesAccess")
              if ka is None:
                  ka = True
              kubernetes_access = _boolish(ka)

              # enum in XRD: admin|edit|view; default edit
              role = (security.get("kubernetesRole") or env_security.get("kubernetesRole") or "edit")

              ingress_env = env.get("ingress") or {}
              storage_env = env.get("storage") or {}
              packages = env.get("packages") or []
              access_env = env.get("access") or {}

              ingress_class  = ingress_env.get("class", "")
              ingress_domain = ingress_env.get("domain", "default")
              ingress_secret = ingress_env.get("secret", "wildcard-tls")

              access_type = (access_env.get("type") or "credentials").strip().lower()

              secret_name = spec.get("secretName") or meta.get("name")
              storage_secret_name = f"{secret_name}-datalab"
              storage_secret_ns = storage_env.get("secretNamespace", "default")

              observed = getattr(req.observed, "resources", None) or {}
              obs_key = f"observe-secret-{secret_name}"
              data_b64 = _extract_data(observed.get(obs_key))

              access_key = _b64get_any(data_b64, ["AWS_ACCESS_KEY_ID","accessKey","username","CONSOLE_ACCESS_KEY","attribute.access"])
              secret_key = _b64get_any(data_b64, ["AWS_SECRET_ACCESS_KEY","secretKey","password","CONSOLE_SECRET_KEY","attribute.secret"])

              session_username = access_key or name

              if access_type != "credentials":
                  session_password = "*"
              else:
                  session_password = secret_key or "*"

              allow_web_egress = {
                  "apiVersion": "networking.k8s.io/v1",
                  "kind": "NetworkPolicy",
                  "metadata": {"name": "allow-web-egress"},
                  "spec": {
                      "podSelector": {},
                      "policyTypes": ["Egress"],
                      "egress": [
                          {
                              "to": [
                                  {"namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": "kube-system"}}}
                              ],
                              "ports": [
                                  {"protocol": "UDP", "port": 53},
                                  {"protocol": "TCP", "port": 53}
                              ]
                          },
                          {
                              "to": [
                                  {"ipBlock": {"cidr": "10.0.0.0/8"}},
                                  {"ipBlock": {"cidr": "172.16.0.0/12"}},
                                  {"ipBlock": {"cidr": "192.168.0.0/16"}},
                                  {"ipBlock": {"cidr": "100.64.0.0/10"}}
                              ]
                          },
                          { "to": [ {"ipBlock": {"cidr": "fc00::/7"}} ] },
                          { "to": [ {"namespaceSelector": {}} ] },
                          { "to": [ {"ipBlock": {"cidr": "0.0.0.0/0", "except": ["169.254.42.42/32"]}} ] },
                          { "to": [ {"ipBlock": {"cidr": "::/0", "except": ["fd00:42::42/128"]}} ] }
                      ]
                  }
              }

              workshop = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "Workshop",
                  "metadata": {"name": name},
                  "spec": {
                      "title": "Default DataLab",
                      "description": "A default DataLab environment.",
                      "version": "1.0",
                      "session": {
                          "applications": {
                              "console": {"enabled": False},
                              "editor": {"enabled": True},
                              "slides": {"enabled": False},
                              "terminal": {"enabled": True},
                              "vcluster": {"enabled": vcluster, "version": "1.30"},
                              "workshop": {"enabled": bool(files)}
                          },
                          "dashboards": [
                              {"name": "Data", "url": "$(ingress_protocol)://data-$(session_name).$(ingress_domain)/"}
                          ],
                          "ingresses": [
                              {
                                  "name": "data",
                                  "protocol": "http",
                                  "host": "data.$(workshop_namespace).svc.$(cluster_domain)",
                                  "port": 8080
                              }
                          ],
                          "resources": {"memory": memory, "storage": storage},
                          "namespaces": {
                              "budget": budget,
                              "role": role,
                              "security": {
                                  "policy": policy,
                                  "token": {"enabled": kubernetes_access}
                              }
                          },
                          "envFrom": [{"secretRef": {"name": storage_secret_name}}],
                          "objects": []
                      },
                      "workshop": {
                          "files": files,
                          "packages": packages
                      },
                      "environment": {
                          "secrets": [{"name": storage_secret_name, "namespace": storage_secret_ns}],
                          "objects": [
                              allow_web_egress,
                              {
                                  "apiVersion": "v1",
                                  "kind": "PersistentVolumeClaim",
                                  "metadata": {"name": storage_secret_name},
                                  "spec": {
                                      "accessModes": ["ReadOnlyMany"],
                                      "resources": {"requests": {"storage": "1Mi"}},
                                      "storageClassName": "csi-rclone"
                                  }
                              },
                              {
                                  "apiVersion": "apps/v1",
                                  "kind": "Deployment",
                                  "metadata": {
                                      "name": "data",
                                      "labels": {
                                          "app.kubernetes.io/instance": "data",
                                          "app.kubernetes.io/name": "data"
                                      }
                                  },
                                  "spec": {
                                      "replicas": 1,
                                      "selector": {
                                          "matchLabels": {
                                              "app.kubernetes.io/instance": "data",
                                              "app.kubernetes.io/name": "data"
                                          }
                                      },
                                      "template": {
                                          "metadata": {
                                              "labels": {
                                                  "app.kubernetes.io/instance": "data",
                                                  "app.kubernetes.io/name": "data"
                                              }
                                          },
                                          "spec": {
                                              "serviceAccountName": "$(service_account)",
                                              "containers": [{
                                                  "name": "data",
                                                  "image": "ghcr.io/versioneer-tech/package-r:v2025.7.1",
                                                  "imagePullPolicy": "Always",
                                                  "ports": [{"name": "http", "containerPort": 8080}],
                                                  "env": [
                                                      {"name": "FB_AUTH_MAPPER", "value": "writer-noshare"},
                                                      {"name": "WORKSPACE", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_ROOT", "value": "/data"},
                                                      {"name": "FB_BRANDING_NAME", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_AUTH_HEADER", "value": "Accept"},
                                                      {"name": "AWS_ACCESS_KEY_ID", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ACCESS_KEY_ID"}}},
                                                      {"name": "AWS_SECRET_ACCESS_KEY", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_SECRET_ACCESS_KEY"}}},
                                                      {"name": "AWS_REGION", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_REGION"}}},
                                                      {"name": "AWS_ENDPOINT_URL", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ENDPOINT_URL"}}},
                                                      {"name": "AWS_S3_FORCE_PATH_STYLE", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_S3_FORCE_PATH_STYLE"}}}
                                                  ],
                                                  "resources": {
                                                      "requests": {"cpu": "100m", "memory": "128Mi"},
                                                      "limits": {"cpu": "1", "memory": "512Mi"}
                                                  },
                                                  "volumeMounts": [{"name": "data", "mountPath": "/data"}]
                                              }],
                                              "volumes": [{"name": "data", "persistentVolumeClaim": {"claimName": storage_secret_name}}]
                                          }
                                      }
                                  }
                              },
                              {
                                  "apiVersion": "v1",
                                  "kind": "Service",
                                  "metadata": {"name": "data"},
                                  "spec": {
                                      "type": "ClusterIP",
                                      "selector": {
                                          "app.kubernetes.io/instance": "data",
                                          "app.kubernetes.io/name": "data"
                                      },
                                      "ports": [
                                          {"name": "http", "port": 8080, "targetPort": "http", "protocol": "TCP"}
                                      ]
                                  }
                              }
                          ]
                      }
                  }
              }

              if policy == "privileged":
                  workshop["spec"]["session"]["applications"]["docker"] = {
                      "enabled": True,
                      "storage": "20Gi"
                  }

              if vcluster:
                  service_cidr = (
                      str((env.get("network") or {}).get("serviceCIDR") or "") or
                      "10.43.0.0/16"
                  )
                  workshop["spec"]["session"]["objects"].append({
                      "apiVersion": "v1",
                      "kind": "ConfigMap",
                      "metadata": {
                          "name": "vc-cidr-my-vcluster",
                          "namespace": "$(session_namespace)-vc"
                      },
                      "data": {"cidr": service_cidr}
                  })

              environment = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "WorkshopEnvironment",
                  "metadata": {"name": name},
                  "spec": {
                      "analytics": {"amplitude": {"trackingId": ""}},
                      "cookies": {},
                      "environment": {"objects": [], "secrets": []},
                      "request": {"enabled": False},
                      "session": {"ingress": {"class": ingress_class, "domain": ingress_domain, "secret": ingress_secret}},
                      "theme": {"name": "default-website-theme"},
                      "workshop": {"name": name}
                  }
              }

              def emit(kind, manifest, key_suffix=""):
                  suffix = f"-{name}{('-' + key_suffix) if key_suffix else ''}"
                  key = f"{kind.lower()}{suffix}"
                  body = {
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                          "forProvider": {"manifest": manifest},
                          "readiness": {"policy": "SuccessfulCreate"},
                          "watch": False
                      }
                  }
                  rsp.desired.resources[key].resource.update(body)

              emit("Workshop", workshop)
              emit("WorkshopEnvironment", environment)

              for sid in sessions:
                  session_manifest = {
                      "apiVersion": "training.educates.dev/v1beta1",
                      "kind": "WorkshopSession",
                      "metadata": {"name": f"{name}-{sid}"},
                      "spec": {
                          "environment": {"name": name},
                          "session": {
                              "id": str(sid),
                              "ingress": {"domain": ingress_domain, "secret": ingress_secret},
                              "env": [
                                  {"name": "SESSION_NAME", "value": f"{name}-{sid}"},
                                  {"name": "FRAME_ANCESTORS", "value": ""}
                              ],
                              "username": session_username,
                              "password": session_password
                          }
                      }
                  }
                  emit("WorkshopSession", session_manifest, key_suffix=str(sid))

    - step: detect-educates-status
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
            from crossplane.function.proto.v1 import run_function_pb2 as fnv1
            from google.protobuf import json_format as jf
            from google.protobuf import struct_pb2 as st

            def _to_dict(s):
                return {} if s is None else jf.MessageToDict(s, preserving_proto_field_name=True)

            def _extract_manifest(objres):
                if not objres or not getattr(objres, "resource", None):
                    return {}
                od = _to_dict(objres.resource)
                atp = (od.get("status") or {}).get("atProvider") or {}
                return (atp.get("manifest") or (atp.get("raw") or {}).get("manifest") or {}) or {}

            def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
                observed = getattr(req.observed, "resources", None) or {}
                xr_obs = _to_dict(req.observed.composite.resource)
                meta = xr_obs.get("metadata", {}) or {}
                spec = xr_obs.get("spec", {}) or {}
                name = meta.get("name")

                sessions_map = {}

                for sid in spec.get("sessions") or []:
                    key = f"workshopsession-{name}-{sid}"
                    manifest = _extract_manifest(observed.get(key))
                    if not manifest:
                        continue

                    ws_spec = (manifest.get("spec") or {}).get("session") or {}
                    ws_id = str(ws_spec.get("id") or sid)

                    educates = (manifest.get("status") or {}).get("educates") or {}
                    phase = educates.get("phase")
                    url = educates.get("url")

                    if phase == "Running" and url:
                        sessions_map[ws_id] = {"url": url}

                cur_status = (xr_obs.get("status") or {}).copy()
                cur_sessions = (cur_status.get("sessions") or {}).copy()
                cur_sessions.update(sessions_map)
                cur_status["sessions"] = cur_sessions

                v = st.Value()
                jf.ParseDict(cur_status, v)
                rsp.desired.composite.resource.fields["status"].CopyFrom(v)

    - step: detect-datalab-status
      functionRef:
        name: crossplane-contrib-function-auto-ready
