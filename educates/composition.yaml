apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: provider-datalab
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Datalab
  mode: Pipeline
  pipeline:
    - step: prepare-environment
      functionRef:
        name: crossplane-contrib-function-environment-configs
      input:
        apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          environmentConfigs:
            - type: Reference
              ref:
                name: datalab

    - step: keycloak
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or (spec.get("claimRef", {}) or {}).get("name") or "<name-missing>"
              ns = meta.get("namespace") or (spec.get("claimRef", {}) or {}).get("namespace") or "<namespace-missing>"

              ctx = _to_dict(req.context)
              env = (ctx.get("apiextensions.crossplane.io/environment", {}) or {})
              iam_env = (env.get("iam") or {})
              ingress_env = (env.get("ingress") or {})

              realm = iam_env.get("realm", "<iam-realm-missing>")
              domain = ingress_env.get("domain", "<ingress-domain-missing>")
              url = f"https://{name}.{domain}"

              def put(key_base, body_base):
                  key = f"{key_base}-{name}"
                  body = body_base.copy()
                  md = body.setdefault("metadata", {})
                  md.setdefault("name", name if key_base != "keycloak-role" else f"{name}-ws-access")
                  md.setdefault("namespace", ns)
                  ann = md.setdefault("annotations", {})
                  ann["crossplane.io/composition-resource-name"] = key
                  rsp.desired.resources[key].resource.update(body)

              put("keycloak-group", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Group",
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": { "name": name, "realmId": realm }
                  }
              })

              put("keycloak-mapper", {
                  "apiVersion": "openidgroup.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "GroupMembershipProtocolMapper",
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": {
                          "claimName": "groups",
                          "clientIdSelector": { "matchLabels": { "crossplane.io/claim-name": name } },
                          "addToAccessToken": False,
                          "addToIdToken": True,
                          "addToUserinfo": False,
                          "fullPath": False,
                          "name": "group-membership-mapper",
                          "realmId": realm
                      }
                  }
              })

              put("keycloak-client", {
                  "apiVersion": "openidclient.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Client",
                  "metadata": {
                      "labels": { "crossplane.io/claim-name": name }
                  },
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": {
                          "name": name,
                          "clientId": name,
                          "rootUrl": url,
                          "adminUrl": url,
                          "accessType": "PUBLIC",
                          "standardFlowEnabled": True,
                          "implicitFlowEnabled": True,
                          "directAccessGrantsEnabled": False,
                          "serviceAccountsEnabled": False,
                          "oauth2DeviceAuthorizationGrantEnabled": True,
                          "webOrigins": [f"{url}/*", "http://localhost:*"],
                          "validRedirectUris": [f"{url}/*", "http://localhost:*"],
                          "realmId": realm
                      }
                  }
              })

              put("keycloak-role", {
                  "apiVersion": "role.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Role",
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": {
                          "name": "ws_access",
                          "clientIdRef": { "name": name, "policy": { "resolution": "Required" } },
                          "realmId": realm
                      }
                  }
              })

              put("keycloak-roles", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Roles",
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": {
                          "realmId": realm,
                          "groupIdRef": { "name": name, "policy": { "resolution": "Required" } },
                          "roleIdsRefs": [
                              { "name": f"{name}-ws-access", "policy": { "resolution": "Required" } }
                          ]
                      }
                  }
              })

              owner = spec.get("owner")
              members = list(spec.get("members", []) or [])
              if owner and owner not in members:
                  members.insert(0, owner)

              put("keycloak-memberships", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Memberships",
                  "spec": {
                      "providerConfigRef": { "name": "provider-keycloak", "kind": "ProviderConfig" },
                      "forProvider": {
                          "groupIdRef": { "name": name, "policy": { "resolution": "Required" } },
                          "realmId": realm,
                          "members": members
                      }
                  }
              })

    - step: educates
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or (spec.get("claimRef", {}) or {}).get("name") or "<name-missing>"
              ns = meta.get("namespace") or (spec.get("claimRef", {}) or {}).get("namespace") or "<namespace-missing>"

              ctx = _to_dict(req.context)
              env = (ctx.get("apiextensions.crossplane.io/environment", {}) or {})
              ingress_env = (env.get("ingress") or {})
              session_env = (env.get("session") or {})
              storage_env = (env.get("storage") or {})

              ingress_class  = ingress_env.get("class", "")
              ingress_domain = ingress_env.get("domain", "<ingress-domain-missing>")
              ingress_secret = ingress_env.get("secret", "wildcard-tls")
              session_suffix = session_env.get("suffix", "s001")

              storage_secret_name    = storage_env.get("secretName", "<storage-secretname-missing>")
              storage_secret_ns      = storage_env.get("secretNamespace", "<storage-secretnamespace-missing>")
              storage_secret_rclone  = f"{storage_secret_name}-rclone"

              allow_dns_env = {
                "apiVersion": "networking.k8s.io/v1",
                "kind": "NetworkPolicy",
                "metadata": {"name": "allow-dns"},
                "spec": {
                  "podSelector": {},
                  "policyTypes": ["Egress"],
                  "egress": [{
                    "to": [{
                      "namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": "kube-system"}},
                      "podSelector": {}
                    }],
                    "ports": [{"protocol":"UDP","port":53},{"protocol":"TCP","port":53}]
                  }]
                }
              }

              allow_dns_session = {
                "apiVersion": "networking.k8s.io/v1",
                "kind": "NetworkPolicy",
                "metadata": {"name": "allow-dns"},
                "spec": {
                  "podSelector": {},
                  "policyTypes": ["Egress"],
                  "egress": [{
                    "to": [{
                      "namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": "kube-system"}},
                      "podSelector": {}
                    }],
                    "ports": [{"protocol":"UDP","port":53},{"protocol":"TCP","port":53}]
                  }]
                }
              }

              allow_session_to_data = {
                "apiVersion": "networking.k8s.io/v1",
                "kind": "NetworkPolicy",
                "metadata": {"name": "allow-session-to-data"},
                "spec": {
                  "podSelector": {
                    "matchLabels": {
                      "app.kubernetes.io/name": "data",
                      "app.kubernetes.io/instance": "data"
                    }
                  },
                  "policyTypes": ["Ingress"],
                  "ingress": [{
                    "from": [{
                      "namespaceSelector": {
                        "matchLabels": {
                          "training.educates.dev/component": "session",
                          "training.educates.dev/environment.name": name
                        }
                      }
                    }],
                    "ports": [{"protocol": "TCP", "port": 8080}]
                  }]
                }
              }

              allow_to_environment_data = {
                "apiVersion": "networking.k8s.io/v1",
                "kind": "NetworkPolicy",
                "metadata": {"name": "allow-to-environment-data"},
                "spec": {
                  "podSelector": {},
                  "policyTypes": ["Egress"],
                  "egress": [{
                    "to": [{
                      "namespaceSelector": { "matchLabels": { "kubernetes.io/metadata.name": name } },
                      "podSelector": {
                        "matchLabels": {
                          "app.kubernetes.io/name": "data",
                          "app.kubernetes.io/instance": "data"
                        }
                      }
                    }],
                    "ports": [{"protocol": "TCP", "port": 8080}]
                  }]
                }
              }

              workshop = {
                "apiVersion": "training.educates.dev/v1beta1",
                "kind": "Workshop",
                "metadata": { "name": "default-workshop" },
                "spec": {
                  "title": "Default DataLab",
                  "description": "A default DataLab environment.",
                  "session": {
                    "applications": {
                      "console":   {"enabled": False},
                      "editor":    {"enabled": True},
                      "slides":    {"enabled": False},
                      "terminal":  {"enabled": True},
                      "vcluster":  {"enabled": False},
                      "workshop":  {"enabled": True}
                    },
                    "dashboards": [
                      { "name": "Data", "url": "$(ingress_protocol)://data-$(session_name).$(ingress_domain)/" }
                    ],
                    "ingresses": [
                      { "name": "data", "protocol": "http", "host": "data.$(workshop_namespace).svc.$(cluster_domain)", "port": 8080 }
                    ],
                    "resources": { "storage": "1Gi" },
                    "namespaces": { "budget": "medium", "security": { "policy": "baseline" } },
                    "envFrom": [ { "secretRef": { "name": storage_secret_name } } ],
                    "objects": [
                      allow_dns_session,
                      allow_to_environment_data
                    ]
                  },
                  "version": "8.3",
                  "workshop": {
                    "files": [
                      {
                        "image": { "url": "ghcr.io/versioneer-tech/datalab-example:0.1-rc.1" },
                        "includePaths": ["/content/**", "/data/**", "/README.md"],
                        "path": "."
                      }
                    ],
                    "packages": [
                      { "name": "awscli",
                        "files": [ { "image": { "url": "ghcr.io/versioneer-tech/educates-extension-packages/awscli:v2.29.0" } } ] },
                      { "name": "rclone",
                        "files": [ { "image": { "url": "ghcr.io/versioneer-tech/educates-extension-packages/rclone:v1.71.0" } } ] }
                    ]
                  },
                  "environment": {
                    "secrets": [
                      { "name": storage_secret_name,   "namespace": storage_secret_ns },
                      { "name": storage_secret_rclone, "namespace": storage_secret_ns }
                    ],
                    "objects": [
                      allow_dns_env,
                      allow_session_to_data,
                      {
                        "apiVersion": "v1",
                        "kind": "PersistentVolumeClaim",
                        "metadata": { "name": storage_secret_rclone },
                        "spec": {
                          "accessModes": ["ReadOnlyMany"],
                          "resources": { "requests": { "storage": "1Mi" } },
                          "storageClassName": "csi-rclone"
                        }
                      },
                      {
                        "apiVersion": "apps/v1",
                        "kind": "Deployment",
                        "metadata": {
                          "name": "data",
                          "labels": { "app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data" }
                        },
                        "spec": {
                          "replicas": 1,
                          "selector": { "matchLabels": { "app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data" } },
                          "template": {
                            "metadata": { "labels": { "app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data" } },
                            "spec": {
                              "serviceAccountName": "$(service_account)",
                              "containers": [
                                {
                                  "name": "data",
                                  "image": "ghcr.io/versioneer-tech/package-r:v2025.7.1",
                                  "imagePullPolicy": "Always",
                                  "ports": [{ "name": "http", "containerPort": 8080 }],
                                  "env": [
                                    { "name": "FB_AUTH_MAPPER", "value": "writer-share" },
                                    { "name": "WORKSPACE", "valueFrom": { "fieldRef": { "fieldPath": "metadata.namespace" } } },
                                    { "name": "FB_ROOT", "value": "/data" },
                                    { "name": "FB_BRANDING_NAME", "valueFrom": { "fieldRef": { "fieldPath": "metadata.namespace" } } },
                                    { "name": "FB_AUTH_HEADER", "value": "Accept" },
                                    { "name": "AWS_ACCESS_KEY_ID",     "valueFrom": { "secretKeyRef": { "name": storage_secret_name, "key": "AWS_ACCESS_KEY_ID" } } },
                                    { "name": "AWS_SECRET_ACCESS_KEY", "valueFrom": { "secretKeyRef": { "name": storage_secret_name, "key": "AWS_SECRET_ACCESS_KEY" } } },
                                    { "name": "AWS_REGION",            "valueFrom": { "secretKeyRef": { "name": storage_secret_name, "key": "AWS_REGION" } } },
                                    { "name": "AWS_ENDPOINT_URL",      "valueFrom": { "secretKeyRef": { "name": storage_secret_name, "key": "AWS_ENDPOINT_URL" } } },
                                    { "name": "AWS_S3_FORCE_PATH_STYLE", "value": "true" }
                                  ],
                                  "resources": {
                                    "requests": { "cpu": "100m", "memory": "128Mi" },
                                    "limits":   { "cpu": "1",    "memory": "512Mi" }
                                  },
                                  "volumeMounts": [ { "name": "data", "mountPath": "/data" } ]
                                }
                              ],
                              "volumes": [ { "name": "data", "persistentVolumeClaim": { "claimName": storage_secret_rclone } } ]
                            }
                          }
                        }
                      },
                      {
                        "apiVersion": "v1",
                        "kind": "Service",
                        "metadata": { "name": "data" },
                        "spec": {
                          "type": "ClusterIP",
                          "selector": { "app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data" },
                          "ports": [ { "name": "http", "port": 8080, "targetPort": "http", "protocol": "TCP" } ]
                        }
                      }
                    ]
                  }
                }
              }

              envres = {
                "apiVersion": "training.educates.dev/v1beta1",
                "kind": "WorkshopEnvironment",
                "metadata": { "name": name },
                "spec": {
                  "analytics": { "amplitude": { "trackingId": "" } },
                  "cookies": {},
                  "environment": { "objects": [], "secrets": [] },
                  "request": { "enabled": False },
                  "session": { "ingress": { "class": ingress_class, "domain": ingress_domain, "secret": ingress_secret } },
                  "theme": { "name": "default-website-theme" },
                  "workshop": { "name": "default-workshop" }
                }
              }

              session = {
                "apiVersion": "training.educates.dev/v1beta1",
                "kind": "WorkshopSession",
                "metadata": { "name": f"{name}-{session_suffix}" },
                "spec": {
                  "environment": { "name": name },
                  "session": {
                    "id": session_suffix,
                    "ingress": { "domain": ingress_domain, "secret": ingress_secret },
                    "env": [
                      { "name": "SESSION_NAME",    "value": f"{name}-{session_suffix}" },
                      { "name": "FRAME_ANCESTORS", "value": "" }
                    ]
                  }
                }
              }

              def emit(kind, manifest):
                  key = f"{kind.lower()}{'-' + name if name else ''}"
                  body = {
                    "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                    "kind": "Object",
                    "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": { "crossplane.io/composition-resource-name": key }
                    },
                    "spec": {
                      "providerConfigRef": { "name": "provider-kubernetes", "kind": "ProviderConfig" },
                      "forProvider": { "manifest": manifest },
                      "readiness": { "policy": "SuccessfulCreate" },
                      "watch": False
                    }
                  }
                  rsp.desired.resources[key].resource.update(body)

              emit("Workshop", workshop)
              emit("WorkshopEnvironment", envres)
              emit("WorkshopSession", session)

    - step: detect-status
      functionRef:
        name: crossplane-contrib-function-auto-ready
