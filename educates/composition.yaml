# Copyright 2025, EOX (https://eox.at) and Versioneer (https://versioneer.at)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: provider-datalab
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Datalab
  mode: Pipeline
  pipeline:
    - step: prepare-environment
      functionRef:
        name: crossplane-contrib-function-environment-configs
      input:
        apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          environmentConfigs:
            - type: Reference
              ref:
                name: datalab

    - step: observe-storage-secret
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              return {} if s is None else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or "<name-missing>"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}

              ns = storage_env.get("secretNamespace") or meta.get("namespace") or "default"

              key = f"secret-observer-{name}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": key},
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {"name": name, "namespace": ns},
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                      "watch": False
                  },
              })

    - step: write-secret-datalab
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import base64 as _base64
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(s):
              if s is None:
                  return {}
              return s if isinstance(s, dict) else _json_format.MessageToDict(s, preserving_proto_field_name=True)

          def _b64get_any(d, keys):
              if not d:
                  return None
              for k in keys:
                  v = d.get(k)
                  if v is None:
                      continue
                  try:
                      return _base64.b64decode(v).decode("utf-8")
                  except Exception:
                      continue
              return None

          def _extract_data(objres):
              if not objres or not getattr(objres, "resource", None):
                  return {}
              od = _to_dict(objres.resource)
              st = (od.get("status") or {}).get("atProvider") or {}
              m1 = st.get("manifest") or {}
              m2 = (st.get("raw") or {}).get("manifest") or {}
              return (m1.get("data") or m1.get("stringData") or m2.get("data") or m2.get("stringData") or {})

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or "<name-missing>"

              ctx = _to_dict(req.context)
              ns_from_xr = meta.get("namespace") or "default"
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              storage_env = env.get("storage") or {}
              ns = storage_env.get("secretNamespace") or ns_from_xr

              obs = (getattr(req.observed, "resources", {}) or {}).get(f"secret-observer-{name}")
              data_b64 = _extract_data(obs)

              access_key = _b64get_any(data_b64, ["AWS_ACCESS_KEY_ID","accessKey","username","CONSOLE_ACCESS_KEY"])
              secret_key = _b64get_any(data_b64, ["AWS_SECRET_ACCESS_KEY","secretKey","password","CONSOLE_SECRET_KEY"])
              endpoint   = _b64get_any(data_b64, ["AWS_ENDPOINT_URL"]) or storage_env.get("endpoint", "")
              region     = _b64get_any(data_b64, ["AWS_REGION"]) or storage_env.get("region", "")
              rtype      = storage_env.get("type", "")
              provider   = storage_env.get("provider", "")
              force_path_style = str(storage_env.get("force_path_style", "true")).lower()

              if not access_key or not secret_key:
                  return

              config_data = (
                  f"[{access_key}]\n"
                  f"type = {rtype}\n"
                  f"provider = {provider}\n"
                  f"endpoint = {endpoint}\n"
                  f"region = {region}\n"
                  f"access_key_id = {access_key}\n"
                  f"secret_access_key = {secret_key}\n"
                  f"force_path_style = {force_path_style}\n"
              )

              out_name = f"{name}-datalab"
              manifest = {
                  "apiVersion": "v1",
                  "kind": "Secret",
                  "metadata": {"name": out_name, "namespace": ns},
                  "type": "Opaque",
                  "stringData": {
                      "remote": access_key,
                      "remotePath": "/",
                      "configData": config_data,
                      "AWS_ACCESS_KEY_ID": access_key,
                      "AWS_SECRET_ACCESS_KEY": secret_key,
                      "AWS_REGION": region,
                      "AWS_ENDPOINT_URL": endpoint,
                      "AWS_S3_FORCE_PATH_STYLE": force_path_style,
                  },
              }

              key = f"secret-{name}-datalab"
              rsp.desired.resources[key].resource.update(manifest)
              rsp.desired.resources[key].ready = True

    - step: keycloak
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or "<name-missing>"
              ns = meta.get("namespace") or "default"

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              iam_env = env.get("iam") or {}
              ingress_env = env.get("ingress") or {}
              realm = iam_env.get("realm", "<iam-realm-missing>")
              domain = ingress_env.get("domain", "<ingress-domain-missing>")
              url = f"https://{name}.{domain}"

              def put(key_base, body_base):
                  key = f"{key_base}-{name}"
                  body = body_base.copy()
                  md = body.setdefault("metadata", {})
                  md.setdefault("name", name if key_base != "keycloak-role" else f"{name}-ws-access")
                  md.setdefault("namespace", ns)
                  ann = md.setdefault("annotations", {})
                  ann["crossplane.io/composition-resource-name"] = key
                  rsp.desired.resources[key].resource.update(body)

              put("keycloak-group", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Group",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {"name": name, "realmId": realm},
                  },
              })

              put("keycloak-mapper", {
                  "apiVersion": "openidgroup.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "GroupMembershipProtocolMapper",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "claimName": "groups",
                          "clientIdSelector": {"matchLabels": {"crossplane.io/claim-name": name}},
                          "addToAccessToken": False,
                          "addToIdToken": True,
                          "addToUserinfo": False,
                          "fullPath": False,
                          "name": "group-membership-mapper",
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-client", {
                  "apiVersion": "openidclient.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Client",
                  "metadata": {"labels": {"crossplane.io/claim-name": name}},
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": name,
                          "clientId": name,
                          "rootUrl": url,
                          "adminUrl": url,
                          "accessType": "PUBLIC",
                          "standardFlowEnabled": True,
                          "implicitFlowEnabled": True,
                          "directAccessGrantsEnabled": False,
                          "serviceAccountsEnabled": False,
                          "oauth2DeviceAuthorizationGrantEnabled": True,
                          "webOrigins": [f"{url}/*", "http://localhost:*"],
                          "validRedirectUris": [f"{url}/*", "http://localhost:*"],
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-role", {
                  "apiVersion": "role.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Role",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "name": "ws_access",
                          "clientIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                      },
                  },
              })

              put("keycloak-roles", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Roles",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "realmId": realm,
                          "groupIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "roleIdsRefs": [{"name": f"{name}-ws-access", "policy": {"resolution": "Required"}}],
                      },
                  },
              })

              users = list(spec.get("users", []) or [])

              put("keycloak-memberships", {
                  "apiVersion": "group.keycloak.m.crossplane.io/v1alpha1",
                  "kind": "Memberships",
                  "spec": {
                      "providerConfigRef": {"name": "provider-keycloak", "kind": "ProviderConfig"},
                      "forProvider": {
                          "groupIdRef": {"name": name, "policy": {"resolution": "Required"}},
                          "realmId": realm,
                          "members": users,
                      },
                  },
              })

    - step: educates
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format as _json_format

          def _to_dict(struct):
              return {} if struct is None else _json_format.MessageToDict(struct, preserving_proto_field_name=True)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              name = meta.get("name") or "<name-missing>"
              ns = meta.get("namespace") or "default"

              files = spec.get("files", []) or []
              sessions = list(spec.get("sessions", []) or [])
              vc_raw = spec.get("vcluster", False)
              if isinstance(vc_raw, bool):
                  vcluster = vc_raw
              else:
                  vcluster = str(vc_raw).lower() in ("true","1","yes","on")

              ctx = _to_dict(req.context)
              env = ctx.get("apiextensions.crossplane.io/environment", {}) or {}
              ingress_env = env.get("ingress") or {}
              storage_env = env.get("storage") or {}

              ingress_class  = ingress_env.get("class", "")
              ingress_domain = ingress_env.get("domain", "<ingress-domain-missing>")
              ingress_secret = ingress_env.get("secret", "wildcard-tls")

              storage_secret_name = f"{name}-datalab"
              storage_secret_ns = storage_env.get("secretNamespace", "<storage-secret-namespace-missing>")

              allow_dns_env = {
                  "apiVersion": "networking.k8s.io/v1",
                  "kind": "NetworkPolicy",
                  "metadata": {"name": "allow-dns"},
                  "spec": {
                      "podSelector": {},
                      "policyTypes": ["Egress"],
                      "egress": [{
                          "to": [{
                              "namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": "kube-system"}},
                              "podSelector": {}
                          }],
                          "ports": [{"protocol": "UDP", "port": 53}, {"protocol": "TCP", "port": 53}]
                      }],
                  },
              }

              allow_dns_session = allow_dns_env.copy()

              allow_session_to_data = {
                  "apiVersion": "networking.k8s.io/v1",
                  "kind": "NetworkPolicy",
                  "metadata": {"name": "allow-session-to-data"},
                  "spec": {
                      "podSelector": {"matchLabels": {"app.kubernetes.io/name": "data", "app.kubernetes.io/instance": "data"}},
                      "policyTypes": ["Ingress"],
                      "ingress": [{
                          "from": [{
                              "namespaceSelector": {
                                  "matchLabels": {
                                      "training.educates.dev/component": "session",
                                      "training.educates.dev/environment.name": name
                                  }
                              }
                          }],
                          "ports": [{"protocol": "TCP", "port": 8080}]
                      }],
                  },
              }

              allow_to_environment_data = {
                  "apiVersion": "networking.k8s.io/v1",
                  "kind": "NetworkPolicy",
                  "metadata": {"name": "allow-to-environment-data"},
                  "spec": {
                      "podSelector": {},
                      "policyTypes": ["Egress"],
                      "egress": [{
                          "to": [{
                              "namespaceSelector": {"matchLabels": {"kubernetes.io/metadata.name": name}},
                              "podSelector": {"matchLabels": {"app.kubernetes.io/name": "data", "app.kubernetes.io/instance": "data"}}
                          }],
                          "ports": [{"protocol": "TCP", "port": 8080}]
                      }],
                  },
              }

              workshop = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "Workshop",
                  "metadata": {"name": name},
                  "spec": {
                      "title": "Default DataLab",
                      "description": "A default DataLab environment.",
                      "version": "1.0",
                      "session": {
                          "applications": {
                              "console": {"enabled": False},
                              "editor": {"enabled": True},
                              "slides": {"enabled": False},
                              "terminal": {"enabled": True},
                              "vcluster": {"enabled": vcluster},
                              "workshop": {"enabled": bool(files or [])}
                          },
                          "dashboards": [{"name": "Data", "url": "$(ingress_protocol)://data-$(session_name).$(ingress_domain)/"}],
                          "ingresses": [{"name": "data", "protocol": "http", "host": "data.$(workshop_namespace).svc.$(cluster_domain)", "port": 8080}],
                          "resources": {"storage": "1Gi"},
                          "namespaces": {"budget": "medium", "security": {"policy": "baseline"}},
                          "envFrom": [{"secretRef": {"name": storage_secret_name}}],
                          "objects": [allow_dns_session, allow_to_environment_data]
                      },
                      "workshop": {
                          "files": files or [],
                          "packages": [
                              {"name": "awscli", "files": [{"image": {"url": "ghcr.io/versioneer-tech/educates-extension-packages/awscli:v2.29.0"}}]},
                              {"name": "rclone", "files": [{"image": {"url": "ghcr.io/versioneer-tech/educates-extension-packages/rclone:v1.71.0"}}]}
                          ]
                      },
                      "environment": {
                          "secrets": [{"name": storage_secret_name, "namespace": storage_secret_ns}],
                          "objects": [
                              allow_dns_env,
                              allow_session_to_data,
                              {
                                  "apiVersion": "v1",
                                  "kind": "PersistentVolumeClaim",
                                  "metadata": {"name": storage_secret_name},
                                  "spec": {
                                      "accessModes": ["ReadOnlyMany"],
                                      "resources": {"requests": {"storage": "1Mi"}},
                                      "storageClassName": "csi-rclone"
                                  }
                              },
                              {
                                  "apiVersion": "apps/v1",
                                  "kind": "Deployment",
                                  "metadata": {
                                      "name": "data",
                                      "labels": {"app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data"}
                                  },
                                  "spec": {
                                      "replicas": 1,
                                      "selector": {"matchLabels": {"app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data"}},
                                      "template": {
                                          "metadata": {"labels": {"app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data"}},
                                          "spec": {
                                              "serviceAccountName": "$(service_account)",
                                              "containers": [{
                                                  "name": "data",
                                                  "image": "ghcr.io/versioneer-tech/package-r:v2025.7.1",
                                                  "imagePullPolicy": "Always",
                                                  "ports": [{"name": "http", "containerPort": 8080}],
                                                  "env": [
                                                      {"name": "FB_AUTH_MAPPER", "value": "writer-share"},
                                                      {"name": "WORKSPACE", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_ROOT", "value": "/data"},
                                                      {"name": "FB_BRANDING_NAME", "valueFrom": {"fieldRef": {"fieldPath": "metadata.namespace"}}},
                                                      {"name": "FB_AUTH_HEADER", "value": "Accept"},
                                                      {"name": "AWS_ACCESS_KEY_ID", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ACCESS_KEY_ID"}}},
                                                      {"name": "AWS_SECRET_ACCESS_KEY", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_SECRET_ACCESS_KEY"}}},
                                                      {"name": "AWS_REGION", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_REGION"}}},
                                                      {"name": "AWS_ENDPOINT_URL", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_ENDPOINT_URL"}}},
                                                      {"name": "AWS_S3_FORCE_PATH_STYLE", "valueFrom": {"secretKeyRef": {"name": storage_secret_name, "key": "AWS_S3_FORCE_PATH_STYLE"}}}
                                                  ],
                                                  "resources": {"requests": {"cpu": "100m", "memory": "128Mi"}, "limits": {"cpu": "1", "memory": "512Mi"}},
                                                  "volumeMounts": [{"name": "data", "mountPath": "/data"}]
                                              }],
                                              "volumes": [{"name": "data", "persistentVolumeClaim": {"claimName": storage_secret_name}}]
                                          }
                                      }
                                  }
                              },
                              {
                                  "apiVersion": "v1",
                                  "kind": "Service",
                                  "metadata": {"name": "data"},
                                  "spec": {
                                      "type": "ClusterIP",
                                      "selector": {"app.kubernetes.io/instance": "data", "app.kubernetes.io/name": "data"},
                                      "ports": [{"name": "http", "port": 8080, "targetPort": "http", "protocol": "TCP"}]
                                  }
                              }
                          ]
                      }
                  }
              }

              environment = {
                  "apiVersion": "training.educates.dev/v1beta1",
                  "kind": "WorkshopEnvironment",
                  "metadata": {"name": name},
                  "spec": {
                      "analytics": {"amplitude": {"trackingId": ""}},
                      "cookies": {},
                      "environment": {"objects": [], "secrets": []},
                      "request": {"enabled": False},
                      "session": {"ingress": {"class": ingress_class, "domain": ingress_domain, "secret": ingress_secret}},
                      "theme": {"name": "default-website-theme"},
                      "workshop": {"name": name}
                  }
              }

              def emit(kind, manifest, key_suffix=""):
                  suffix = f"-{name}{('-' + key_suffix) if key_suffix else ''}"
                  key = f"{kind.lower()}{suffix}"
                  body = {
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key},
                      },
                      "spec": {
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"},
                          "forProvider": {"manifest": manifest},
                          "readiness": {"policy": "SuccessfulCreate"},
                          "watch": False
                      },
                  }
                  rsp.desired.resources[key].resource.update(body)

              emit("Workshop", workshop)
              emit("WorkshopEnvironment", environment)

              for sid in sessions:
                  session_manifest = {
                      "apiVersion": "training.educates.dev/v1beta1",
                      "kind": "WorkshopSession",
                      "metadata": {"name": f"{name}-{sid}"},
                      "spec": {
                          "environment": {"name": name},
                          "session": {
                              "id": str(sid),
                              "ingress": {"domain": ingress_domain, "secret": ingress_secret},
                              "env": [
                                  {"name": "SESSION_NAME", "value": f"{name}-{sid}"},
                                  {"name": "FRAME_ANCESTORS", "value": ""}
                              ]
                          }
                      }
                  }
                  emit("WorkshopSession", session_manifest, key_suffix=sid)

    - step: detect-status
      functionRef:
        name: crossplane-contrib-function-auto-ready
